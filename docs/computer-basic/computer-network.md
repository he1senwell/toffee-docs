# 计算机网络

## 1、常见的HTTP状态码

答案：

这些是参考服务器上任务的预定义状态的标准代码。

### 以下是可用的状态代码格式：

- 1xx - 代表信息响应
- 2xx - 代表成功响应
- 3xx - 表示重定向
- 4xx - 代表客户端错误
- 5xx - 代表服务器错误

最常用的状态码是：

- 101-协议升级，主要用于升级到websocket，也可以用于http2

- 200 - 成功/OK
- 201 - 已创建 - 用于POST或PUT方法。
- 304 - NOT MODIFIED - 用于有条件的GET请求以减少网络的带宽使用。在这里，发送的响应正文应该是空的。
- 401 - UNAUTHORIZED - 当没有与请求一起发送的有效身份验证凭据时放回。
- 403 - FORBIDDEN - 当用户无权访问（或被禁止）资源时发送。
- 404 - NOT FOUND - 资源方法不可用
- 500 - INTERNAL SERVER ERROR - 服务器在运行该方法时抛出了一些异常
- 502 - BAD GATEWAY - 服务器无法从另一个上游服务器获得响应

差不多全部的状态码

- 501 - 尚未实施 - 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。
- 503 - 服务不可用 - 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。
- 504 - 网关超时 - 未及时从上游服务器接收请求。
- 505 - HTTP版本不受支持 - 服务器不支持请求中所使用的HTTP协议版本。
- 202 -  已接受 - 服务器已接受了请求，但尚未对其进行处理。
- 203 - 非授权信息 - 服务器成功处理了请求，但未返回任何内容。
- 204 - 无内容 -  服务器成功处理了请求，但未返回任何内容。
- 205 - 重置内容 - 服务器成功处理了请求，但未返回任何内容。与204响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。
- 206（部分内容）服务器成功处理了部分GET请求。
- 301 - 永久移动 - 请求的网页已被永久移动到新位置。服务器返回此响应（作为对GET或HEAD请求的响应）时，会自动将请求者转到新位置。
- 302 -  临时移动 - 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求，会自动将请求者转到不同的位置。
- 303 - 查看其他位置 - 当请求者应对不同的位置进行单独的GET请求以检索响应时，服务器会返回此代码。对于除HEAD请求之外的所有请求，服务器会自动转到其他位置。
- 305 - i请求者之恶能使用访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的。
- 307 - 临时重定向 - 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求。
- 405 - 方法禁用 -禁用请求中所指定的方法。
- 406 - 不接受 - 无法使用请求的内容特性来响应请求的网页。
- 408 - 请求超时 - 服务器等候请求时超时。
- 409 - 冲突 - 服务器在完成请求时发生请求。
- 410 - 已删除 - 如果请求的资源已被永久删除，服务器返回此响应。
- 411 - 需要有效长度
- 412 - 未满足前提条件
- 413 - 请求实体过大
- 414 - 请求的URI过长
-  415 - 不支持的媒体类型
- 416 - 请求范围不符合要求

## 2、常见的HTTP方法

答案

- GET：用于从服务器获取详细信息，基本上是只读操作。
- POST：此方法用于在服务器上创建新资源。
- PUT：此方法用于更新服务器上的旧|现有资源或替换资源。
- DELETE：此方法用于删除服务器上的资源。
- PATCH：用于修改服务器上的资源。
- OPTIONS：这会获取服务器上支持的资源选项列表。

POST、GET、PUT、DELETE对应于最常称为CRUD操作的创建、读取、更新、删除操作。

- GET、HEAD、OPTIONS是安全且幂等的方法，而PUT和DELETE方法只是幂等的。
- POST和PATCH方法既不安全也不幂等。

## 3、GET和POST的区别？

答案

### 先说结论：

- 它们的本质都是TCP链接，并无区别。
- 但是由于HTTP的规定以及浏览器/服务器的限制，导致他们在应用过程中会有所不同。

### 一般回答：

#### 从HTTP的报文层面看：

- post更安全，不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中
- post发送的数据更大(get有url长度限制)
- post能发送更多的数据类型（get只能发送ASCII字符）
- post比get慢
- post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作(各种搜索查询都是get提交)，目的是资源的获取，读取数据。

#### 从数据库的层面看

get更符合幂等性和安全性

#### 其他方面看比如：

get可以被缓存，被存储，而post不能

#### 从安全性看：

POST的安全性要比GET安全性高。这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里的安全的含义是真正的Security的含义。

## 4、为什么get比post更快

答案

- post请求包含更多的请求头，因为post需要在请求的body部分包含数据，所以会多了几个数据描述部分的首部字段（如：content-type）这其实是微乎其微的。
- 最重要的一条，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据。

#### post请求过程（3次交互）

- ① 浏览器请求tcp连接（第一次握手）
- ② 服务器答应进行tcp连接（第二次握手）
- ③ 浏览器确认，并发送post请求头（第三次握手，这个报文比较小。所以http会在此时进行第一次数据发送）
- ④ 服务器返回100 Continue 响应
- ⑤ 浏览器发送数据
- ⑥ 服务器返回200 OK 响应

#### get请求的过程：（2次交互）

- ① 浏览器请求tcp连接（第一次握手）
- ② 服务器答应进行tcp连接（第二次握手）
- ③ 浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一IC数据发送）
- ④ 服务器返回200 OK响应

也就是说，get的总耗时post的2/3左右。

## 5、说一说UDP和TCP的区别

### UDP:

UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。ICQ短消息使用UDP协议发送信息。

许多程序将使用单独的TCP和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。

### TCP：

TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住较低的网络层会将每个数据包是为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一个信息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。

为确保正确的接收数据，TCP要求在目标计算机成功收到数据时发回一个确认(即ACK)。如果在某个时限内未收到相应的ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机额可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。

### 区别总结：

- 1、 TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。
- 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。
- 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的UDP，，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)。
- 4、每一条TCP连接只能使点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。(单播、多播、广播)
- 5、TCP首部开销20字节；UDP的首部开销小，只有8个字节
- 6、TCP的逻辑通信信道使全双工的可靠信道，UDP则是不可靠信道。

## 6、说一说HTTPS的加密过程

1. server 生成一个公钥和私钥，把

## 7、说一说HTTP和HTTPS的区别

### 主要区别：

- HTTP缺乏加密数据的安全机制，而HTTPS提供SSL或TLS数字证书来保护服务器和客户端之间的通信。
- HTTP在应用层运行，而HTTPS在传输层运行。
- HTTP默认在80端口上运行，而HTTPS默认在443端口上运行。
- HTTP以纯文本传输数据，而HTTPS以密文(加密文本)传输数据。
- HTTP比HTTPS快，因为HTTPS消耗计算能力来加密通信通道。

### 全部区别：

| 范围       | HTTP                                                         | HTTPS                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 协议       | 它是超文本传输协议                                           | 它是一种安全的超文本传输协议                                 |
| 安全       | 它的安全性较低，因为数据可能容易收到黑客攻击                 | 它皆在防止黑客访问关键信息。它对此类攻击是安全的             |
| 端口       | 默认使用80端口                                               | 默认情况下使用端口443                                        |
| 以...开始  | HTTP URL 以http://开头                                       | HTTP URL 以https://开头                                      |
| 应用场景   | 它非常适合为博客等信息消费而设计的网站                       | 如果网站需要收集各种账号等隐私信息，那么它是一种更安全的协议 |
| Scrambling | HTTP不会扰乱要传输的数据。这就是为什么黑客更有可能获得传输的信息 | HTTPS在传输前对数据进行加扰。在接收端，它解扰以恢复原始数据。因此，传输的信息是安全的，不会被黑客入侵 |
| 协议       | 它在TCP/IP级别运行                                           | HTTPS没有任何单独的协议。它使用HTTP运行，但使用加密的TLS/SSL连接。 |
| 域名验证   | HTTP网站不需要SSL                                            | HTTPS需要SSL证书，并由CA签名                                 |
| 数据加密   | HTTP网站不使用加密                                           | HTTPS网站使用数据加密                                        |
| 搜索排名   | HTTP不会提高搜索排名。搜索引擎不会优先考虑HTTP网站           | HTTPS有助于提高搜索排名。由于HTTPS网站是安全网站，因此搜索引擎会为HTTPS提供偏好 |
| 速度       | 速度快                                                       | 比HTTP慢，由于它支持的附加功能，即安全性，与HTTP相比，页面加载速度慢一点 |
| 漏洞       | 易受黑客攻击                                                 | 它是高度安全的，因为数据在通过网络看到之前已被加密           |
| 运行层级   | 应用层协议                                                   | 传输层协议                                                   |

## 8、说一说OSI 7层参考模型：

从下往上

1. **物理层**：完成每一个比特的传输，比特同步，比特编码，传输速率
2. **数据链路层**：完成结点与结点之间数据的交付，也就是相邻物理链路之间数据的传输。物理寻址、差错控制。
3. **网络层**：完成从源主机到目的主机之间的数据的传输。逻辑寻址，源ip地址和目的ip地址信息。
4. **传输层**：对报文进行分割和重组，增加源端口号和目的端口号。流量控制、差错控制、连接控制。 
5. **会话层**：两个进程之间的一次通信就叫做一次对话，完成对话的建立、维护和同步。
6. **表示层**：处理两个系统之间交换信息的语法和语义问题。对数据进行转化、压缩/解压缩，加密/解密。
7. **应用层**：支持用户通过用户代理(浏览器)或者网络接口使用网络服务。文件传输:(FTP)、电子邮件:(STMP)、Web:(HTTP)。

## 9、说一说HTTP协议

#### HTTP/0.9

最早的版本，只有一个命令GET。

#### HTTP/1.0

- 缺点：每个TCP连接只能发送一个请求。
- 解决方法：Connection：keep-alive

#### HTTP/1.1

特性：

1. `长连接`：TCP连接默认不关闭，可以被多个请求复用。对于同一个域名，大多数浏览器允许同时建立6个持久连接。默认开启Connection: keep-alive。
2. `管道机制`: 在同一个TCP连接里，可以同时发送多个请求。但是服务器还是按照请求的顺序进行响应，会造成“对头阻塞”。

HTTP/2

## 10、说一说HTTP首部字段

#### 通用首部字段：

1、`Cache-Control`：操作缓存的工作机制

参数：

 - public：明确表明其他用户也可以利用缓存
 - private：缓存只给特定的用户
 - no-cache：客户端发送这个指令，表示客户端不接收缓存过的响应，必须到服务器取；服务器返回这个指令，指缓存服务器不能对资源进行缓存。其实是不缓存过期资源，要向服务器进行有效期确认后再处理资源。
 - no-store：指不进行缓存
 - max-age：缓存的有效时间（相对时间）

2、`Connection`:

- Connection：keep-Alive(持久连接)
- Connection：不在转发的首部字段名

3、`Date`：表明创建http报文的日期和时间

4、`Pragma`: 兼容http1.0， 与Cache-Control：no-cache含义一样。但只用在客户端发送的请求中，告诉中间服务器不返回缓存。形式唯一：Pragma： no-cache

5、`Trailer`：会事先说明在报文主体后记录了哪些首部字段，该首部字段可以应用在http1.1版本分块传输编码中。

6、`Transfer-Encoding`: chunked(分块传输编码)。

7、`Upgrade`：升级一个成其他的协议，需要额外指定Connection:Upgrade。服务器可用101状态码作为相应返回。

8、`Via`：追踪客户端和服务器之间的请求和响应报文的传输路径。可以避免请求回环发生，所以在经过代理时必须要附加这个字段。

#### 请求首部字段:

1、Accept：通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级q表示优先级的权重值，默认为q=1.0,范围是0~1（可精确到小数点后3位，1为最大值）当服务器提供多种内容时，会先返回权重值最高的媒体类型。

2、Accept-Charset: 支持的字符集的相对优先顺序，跟Accept一样，用q来表示相对优先级。这个字段应用于内容协商机制的服务器驱动协商。

3、Accept-Encoding：支持的内容编码及内容编码的优先级顺序，q表示相对优先级。

内容编码：gzip、compress、deflate。identity，可以使用*作为通配符，指定任意的编码格式

4.Accept-Language：能够处理的自然语言集，以及相对优先级。

## 11、说一说WebSocket

HTML5新提出的，是web浏览器与web服务器之间的全双通信标准。主要是为了解决 ajax 和 comet 里的 xmlhttprequest 附带的缺陷所引起的问题。

#### 特性：

- 推送功能： 服务器可直接发送数据，不需要等待客户端的请求；
- 基于TCP传输协议，并复用HTTP的握手通道。
- 支持双向通信，用于实时传输消息；
- 更好的二进制支持
- 更灵活，更高效。

#### 建立连接过程：

1、客户端：发起协议升级请求

```
GET / HTTP/1.1      `采用HTTP报文格式，只支持get请求`
Host: localhost:8080    
Origin: http://127.0.0.1:3000 
Connection: Upgrade   `表示要升级协议`
Upgrade: websocket    `表示升级到websocket协议`
Sec-WebSocket-Version: 13    `表示websocket 的版本`
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==   `是一个 Base64 encode 的值，是浏览器随机生成的`
Sec-WebSocket-Protocol：chat, superchat  `用来指定一个特定的子协议，一旦这个字段有设置，那么服务器需要在建立连接的响应头中包含同样的字段，内容就是选择的子协议之一。`
```

2、服务端：响应协议升级

```
HTTP/1.1 101 Switching Protocols    `101表示协议切换==`
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU= `经过服务器确认，并且加密过后的 Sec-WebSocket-Key`
Sec-WebSocket-Protocol：chat  `表示最终使用的协议`
```

3、双方握手成功后，就是全双工的通信了，接下来就是用websocket协议来进行通信了。

## 12、说一说Ajax 轮询、长轮询、WebSocket原理解析

**1、ajax轮询**

让浏览器每隔一定的时间就发送一次请求，询问服务器是否有新消息。

**2、长轮询**

采用阻塞模式。客户端发起连接后，如果没消息，服务器不会马上告诉你没消息，而是将这个请求挂起，知道有消息才返回。返回完成或者客户端主动断开后，客户端再次建立连接，周而复始。Comet 就是采用的长轮询。

**3、WebSocket**

WebSocket 是类似 Socket 的TCP长连接通讯模式。一旦WebSocket 连接建立后，后续数据都以帧序列的形式传输。而且浏览器和服务器就可以随时主动发送消息给对象，是全双工通信。

优点：在海量并发及客户端与服务器交互负载流量大的清空下，极大的节省了网络带宽资源的消耗，有明显的性能有优势，且客户端发送和接受是在同一个持久连接上发起，实时性优势明显。

持续更新.....